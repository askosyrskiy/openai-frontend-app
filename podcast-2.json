{"podcast_details": {"podcast_title": "DevOps Paradox", "episode_title": "DOP 224: Are Developer Bootcamps Worth It?", "episode_image": "https://ssl-static.libsyn.com/p/assets/1/3/f/9/13f9df88b6a5bdd1/Devops_Final.jpg", "episode_transcript": " The self-taught route tends to push people into front end and front end frameworks. I don't think it has to be that way. I think people who are more logically minded that prefer to work with data and algorithms and the command line can still become self-taught engineers. This is DevOps Paradox, episode number 224. Are developer boot camps worth it? Welcome to DevOps Paradox. This is a podcast about random stuff in which we, Darren and Victor, pretend we know what we're talking about. Most of the time we mask our ignorance by putting the word DevOps everywhere we can and mix it with random buzzwords like Kubernetes, serverless, CI-CD, team productivity, islands of happiness, and other fancy expressions that make us sound like we know what we're doing. Occasionally we invite guests who do know something, but we do not do that often since they might make us look incompetent. The truth is out there and there is no way we are going to find it. Yes, it's Darren reading this text and feeling embarrassed that Victor made me do it. Here are your hosts, Darren Pope and Victor Farsi. Victor, why did you start DevOps Toolkit, your YouTube channel? Because I was sick of people always sending everything with it depends. It doesn't. You have opinion, tell me your opinions and nobody does or very few. So I wanted to be equally positive as negative depending on what I'm doing. And you don't care if you're right or wrong. It's just your opinion. I mean, I'm wrong all the time. That's how we improve. Otherwise, if I would be always right, that would mean that I'm always doing the same thing. You're always right, Victor. You can never be wrong. I will never admit that I'm wrong unless unless somebody convinces me. Otherwise, that's true. Okay. Why are we talking about this? Well, on today's show, no idea. Well, if you just let me finish, you'll find out. So you're being wrong right now. Come on. I'm not. We already established that. Oh, right. You're always right. So therefore you can't be wrong if you're always look, we have a guest on today. We have Lane Wagner on from boot.dev. Lane, how you doing? Doing great. Thanks for having me on. Now boot.dev is, do you call it self-managed training? What do you want to call it? Yeah. It most neatly fits into e-learning. I kind of chose the boot.dev name a little tongue in cheek because I have a lot of issues with some of the way that modern web dev boot camps work. So in a sense, it's kind of like a boot camp, but very self-paced, very e-learning. So what are your problems with boot camps other than they take your money and run? Well, I feel like that's a good enough reason. I think the biggest problem that I have is the over promise of how much you'll learn. Right. So just kind of from a raw educational standpoint, you can't learn web dev. Really in three months. I think there was a vacuum and maybe this is, I'll try not to go too off topic here, but I think there was a vacuum of web developers in 2015, 2016, 2017, where there was just this insane demand for people that knew how to code. What filled that vacuum was a lot of three month, four month boot camps that really promised they could get you into a high paying web development job very, very quickly. And they could early on. Now that vacuum isn't as vacuous. And I think kind of the proper way to get into the industry now just requires a little more time. I also have gripes with kind of the traditional CS education. And I don't see that as a, as necessary either for, you know, getting a job, particularly as a backend developer. But I think we need to go deeper. I think we need to learn more stuff than we can learn in just three or four months. And that's what I've really been trying to build with boot dev, something interactive that goes deep on this stuff. What do you mean two or three months? I mean, I saw boot camps that in a couple of weeks you're experienced. I would expect to become a principal in a year. I mean, we have a problem of title bloat in the industry as well, but, but yeah, I'm with you. But I'm modest. Principle one, not principle. I don't know what people call it. Three. Not staff or distinguished. No, not staff. No, no, no. That would be just silly. Exactly. Staff is three years. Yeah, exactly. So like we have this problem in my opinion, where the bill of goods for becoming a web developer has been sold short. We're saying that it should happen much faster than it, than it really should happen for most folks. And I really think we should give ourselves a little more time again to learn the craft, just a little more deeply. Like it doesn't, it still doesn't need to take four years before you get your first year. Four years before you get your first job. But I do think a couple of months is greatly exaggerated and can lead to you having a very tough kind of first year on the job. Now, one thing that sort of sets boot dev apart from the others that I've seen, again, ignoring some of my biases as well, is that you focus primarily on backend and not front end. Yeah. Why did you choose to take that route? I think backend developers are forgotten in a sense, which is really strange because I was just pulling data on this from the Stack Overflow dev survey in 2022 last year. And what I found actually really surprised me and it was that there's actually twice as many self-identified backend developers, at least in 2022, as there were front end developers. But if you pay attention to like tech Twitter or tech boot camps, you'll believe that you kind of have to learn HTML and CSS and that all the jobs are in writing react on the front end. And I just don't really think that's the case. I've been a backend developer my whole career. I've done a little bit of front end stuff kind of on the side for side projects or picked up some HTML and CSS here or there. But I think the history of our industry has been that backend development has been dominated by CS graduates, not because you need a CS degree or that it's a requirement for a lot of these jobs. I've certainly worked with plenty of self-taught backend developers. But just that the self-taught route tends to kind of push people into front end and front end frameworks. I don't think it has to be that way. I think people who are more logically minded that prefer to work with data and algorithms and the command line can still become self-taught engineers. So that's why I'm trying to focus on that. I just don't think there's a lot of great options for people to want to jump right into the backend side of things. I think that one of the reasons for that increase in front end, at least at the early level, is because it produces tangible results faster. I can spend a day learning something and I will have a web page, you know now whether it's a good or bad one, but a web page full of colors and pictures and buttons to click. What do I get from a day working on a backend? I get the API that I can execute and I can send a message to that API with CURL and get back hello Victor. Yeah, you get to curl your API. It's a much harder feedback loop. Actually, that's the second day because the first day is figuring out what is curl. Yeah, no, this is actually a huge problem. And I actually think that that's one of the primary reasons why a lot of e-learning starts you out with HTML and CSS. It's like, okay, well, we can just give you this string, this HTML string that you can paste into a file, open your browser, and boom, you have a website. That's been a hard problem that we've been trying to solve. That's been a hard problem we're trying to solve at Boot Dev. Effectively, how do you make learning the backend fun? How do you make it engaging? How do you make it dopamine-inducing? Because opening a web browser and seeing your work is all of those things inherently, whereas building a CRUD server on the backend isn't, right? And you have to think about it a little bit differently. So for example, we do start people off just learning Python on the command line. And you do get a pretty great feedback loop when you're just doing that. It's not as visual, right? You're not seeing a fully-fledged web app right out of the gate, but you are able to do some really interesting things on the command line. You're able to run your code. You're able to output some stuff. The first project in the app, you're kind of analyzing the full text of the Frankenstein novel and outputting some basic analytics to standard out, right? So you can have these feedback loops, but it's a little harder to engineer. And maybe we'll talk about this later, but now I'm getting kind of to the end of the backend career path and I'm building things like CI, CD courses. And I desperately want those courses to be just as engaging as the first ones in that, like, you can interact in your browser. Everything's hands-on. You're getting automatic feedback about whether you did the assignment correctly or not. But it's a lot harder of an engineering problem to solve because now I'm not just running Python code and checking tests to see if you got the assignment correct. I'm like having you create repos on GitHub and checking your GitHub actions output and stuff like that. So it actually gets really complex down the line. CB I want to go back to something that may only exist in the US. So Victor, you can tell me if it's true or not true over in Europe. We're talking about taking people through boot camps. Let's take boot dev off the list for a second. Let's go a little more meta here. Not meta, meta, but meta. If you have an entry level person doing front end, backend, and what they're really trying to do is get to the money. Should they have just gone into the skilled trades? Electrician, plumber, welder. Because my nephew, he's older now, but when he got out of welding school, he was a very cool. His first paying job was $180,000 a year. This was in the late 90s and he's only gone up from there as a welder. Is there something wrong in our heads being people that type on keyboards that we look back at the skilled trades and say, there's no way I'm going to do that. There's no money in that. And I can tell you by fact, that's not true. In fact, just to put a point on it, I had a plumber come by today to do a repair. It took him three minutes, $150 later for me out of pocket. I don't know, but I do know that I had my sprinklers fixed last week and it took about 45 minutes and I paid $250. And at the end of the day, it was unscrewing some pipes and screwing some other pipes back in just for the money. You might be absolutely right. I've never been a plumber or an electrician, but coding is not the only way to make good money as a quote unquote skilled laborer without a degree. I think you're 100% correct. And there's some other things that could definitely work. Is it the same thing over in Europe, Victor, or at least similar? You would need to be director of a company, a big bank to get the money you mentioned. Absolutely not. I mean, Europe is generally lower salaries and lower also expenses. So maybe all leave us out, right? But yeah, what did you say? 180K? That's not happening. That's not even close. Okay. I just thought it was interesting. And maybe for, cause a lot of the people that listen to us are in the U S it's still a lot of people like, well, I need to go to college. I need to get a CS degree. It's like, if you're just going that route, if you're more happy doing the other things, at least in the U S we need those people because those people are getting older and dying out each day. It takes six weeks to schedule an appointment to get a landscape route where I live right now. It's really hard to get that kind of work done. Besides money, which I don't agree fully. I think that software is actually one of the better paying, if not very well paid in the industry, right? Generally speaking, not necessarily compared to the examples you just said, but it's very, very well paid. And on top of that, it has maybe even the best working conditions compared to any industry. Which other industry you get to work in an office that has a ping pong table and video games and stuff like that, right? It's a good profession, right? Without comparing it really financially with filters or whatever the example was. I just figured I would ask because here's somebody that's trying to effectively build a bootcamp like infrastructure. And if he's seen other people just like, eh, I'm going to go back to my other thing because this is too hard. Or they people find out they don't like to work in an office. We have some pretty crazy examples of students that have joined boot dev, just like this one, boot dev. Just last week, I had a medical doctor from Turkey join. I didn't know this, but apparently medical doctors in Turkey do not get paid very well. And working in the ER is very stressful. So people get into this industry for all sorts of reasons. And I don't actually think that a CS degree is always the wrong option. I have a CS degree and I think for a lot of 18 year olds, a CS degree still makes the most sense when it comes to learning how to code. Especially if you have a scholarship, especially if you're not going into student loan debt, there's all those sorts of factors. But for people later in life, like this doctor in Turkey who's been coding for fun for a few years and now wants to get serious and actually start a career in it. Those are the people I'm trying to help with boot dev. I don't necessarily think it's for everyone. I don't think back in development is for everyone, but for the people that do know that they like working with data, that know they like working with code, they enjoy algorithms and puzzles and things like that, I think there can just be such a more effective and fun way to learn the skills that you need to learn really to just be able to do the stuff on the job that you're going to need to do. Because I do look at development especially as more of a trade than an academic pursuit. So how did you end up at boot dev? You just woke up one morning and it's like, hey, I'm going to create this. If you're looking at this, we're recording this in May, towards the end of May. You're listening to this in August. When I first saw his site, it was not the way it is now. If you're into mid journey or any of the other generative AI image generation things, you need to go check this out. Even if you don't go sign up for any of the courses, you need to go check out the images they've been generating. So anyway, how did you end up at boot dev? So I was a backend engineering manager a couple of years ago when I started the project. And I started it for a couple of reasons. I was looking at first, I had a counterpart at my same company who was the hiring manager for the front end team on our product. So we had two teams working on the same product. My team kind of specialized on the data and back inside of the stack. His team kind of focused on the front end and the application back end. So like they had like kind of a node.js plus react app that handled the visuals. And then my team primarily wrote Go and handled kind of all the like back end and database and aggregation type of logic. Anyways, when I went to hire for a junior Go developer, I'd get like 10 or 15 applications. When my front end counterpart hiring manager would open up a job rec on his team, he would get like 150 applications. This order of magnitude difference in kind of the number of applications. I'm like, why is it so much harder for me to find back end developers, especially back end developers that know how to write Go or some of the other technologies that we're using. And we looked around and like a ton of the developers that are applying on my team, like they all had CS degrees for the most part. Like very rarely does someone apply without a CS degree, even though I didn't require a CS degree. And again, on the front end side, like a CS degree also wasn't required, but the majority of the candidates did not have a CS degree. They were either bootcamp graduates or had been self-learning online. Also the quality of the candidates on the front end side just tend to be like way lower, like people learning for a much smaller amount of time. This kind of goes back to what we talked about a few minutes ago, where I think that the market was in a sense just kind of flooded with junior front end developers. And my belief is that we just need to go a little bit deeper on this stuff, not spend three months, but spend nine months, spend 12 months learning this stuff. And we can learn the like quote unquote complex stuff. Sometimes backend seems really, really scary to new developers, but I don't necessarily think it needs to be that way. I got really good at writing Python scripts way before I ever got good with CSS. So I think we can just think about this differently. And so that's kind of where it started. I originally built boot dev as just a place to learn Golang online. So it was effectively a tour of Go plus like answer verification. And it started there and just kept growing because I kept wanting to add more and more features for prospective backend developers. For a while, I thought it was going to be a computer science degree online, but then I realized like a lot of the stuff in my CS degree, I was kind of frustrated with in terms of like, I don't seem to use it very often in my job. So I'd rather focus on DevOps stuff like CI, CD stuff, Kubernetes and Docker. Those are things that I never learned in my CS degree, but have actually been immensely valuable in my various positions. So we kind of pivoted to being very specific on backend development. So anyways, I was kind of just building it on the side as a hiring manager for a couple of years and finally went full-time on the project in September of last year. So it's been about nine months now. In fact, I probably originally got in touch with you guys right around when I went full-time. Now I have one employee and we just keep putting out content. And like you said, generating mid-journey images. But it's also more fractured backend developer, right? I would assume that when you were looking for people, right? For backend, you were looking for backend developers in Python or whatever it is, right? That's a fraction potentially of people who would apply because some people are Java developers, some people are Go developers or Elixir, whatever it is, right? While front-end developer can apply realistically to almost any job offer. I mean, I know that there are differences. You can say, oh, I'm very good at React and you're asking for Angular. But beyond those differences, it's JavaScript, HTML, CSS, period, right? Yeah, that's a good point. I mean, if you know JavaScript, HTML, CSS, you can apply for a lot of jobs. I mean, I would argue that on the front-end side, you have a very fractured ecosystem with React and Svelte and Vue and Angular. And on the backend side, you're not only fractured by framework, but language and framework. And I mean, the way we look at Go development is like very few developers use a framework in Go. It's because of the rich standard library. We tend to use like kind of glued together libraries rather than use one cohesive framework. But you're right, that could be a contributing factor to the whole thing. But I really do, I guess it's just anecdotally, I haven't pulled data on this, but I do believe that there is a higher expectation, at least among candidates, that they need to have a CS degree to work on the backend. And just from what I've seen in the wild, that's really just not the case. Very few jobs are requiring CS degrees on either side of the stack these days. Are the requirements time-wise the same? If I give you two people, both of them spend the equal amount of time, half a year, three months, doesn't matter what it is, right? On front and back, would you consider them the same on a level in a way that can I be equally skilled in backend with the same amount of time? The hard problem with this question, and I get this question a lot, I think it's a great question, is that there is no binary point in time. There's no threshold that you cross when you become job ready. I've worked with developers that I definitely felt like were not prepared for the job. And it was really frustrating to work with them. On the other hand, I've also known people that I think waited way too long before starting their job search, feeling like they weren't ready. So that's the first problem, is there is no magic threshold. The only real threshold there is, at some level of experience, let's say one year, if you start your job search, how long and how many different jobs are you going to have to apply to before you finally find a good match? And I think on the front end side, that length of time used to be lower. So again, if you look back in like 2017, 2018, kind of the golden age of boot camps, companies were very willing to train up developers that really couldn't provide value to the business for six months, nine months, just because they were so desperate for warm bodies, right? It's okay, we'll bring you on. We'll have our seniors kind of help you out and get you up to speed. That's okay. I think the market in 2022 and 2023 has been very different with kind of this tech recession that we've gone through, where the bar has essentially just been set higher. If you'd asked me three or four years ago, I would have said, maybe learning, like getting job ready on the back end takes, I don't know, 50% longer, 75% longer than it would take on the front end. But actually, that's changed quite a bit. And again, this year and last year, I'd say it's much closer, maybe 10 or 20% longer to learn the stuff on the back end. Like, indisputably, there's more stuff to learn on the back end. But I think that now because competition has risen so much on the front end, you really have to know your stuff to be able to get in the door. Let's stay with the getting in the door idea. Is part of our problem, I can't believe I'm talking about this, is part of the problem that we're actually not working in offices and bouncing stuff off face to face when it comes to the juniors, specifically the juniors? It's a good question. So on the about page of boot dev, so blog.boot.dev slash about, I talk about this and I say, I recommend that anyone who can should get an on-site local job for their first job. Like I know that there's extending the circumstances with that is not possible, right? If you live in a country that doesn't have good local jobs or whatever, but if possible, if it makes sense, I highly recommend starting in an office for exactly the reason that you just mentioned. Like you do most of your learning in those first few jobs at lunch, right? Or when you spin around and whiteboard something with a senior dev that's on your team, I think remote work kills a lot of that natural collaboration and learning that just kind of spontaneously happens, right? Because in a remote environment, you kind of have to ask, you'd be like, oh, I have this question. Hey, senior dev on my team, can we hop on a call and talk about it? Or maybe we'll just have a Slack, a few Slack messages back and forth. I think remote work is fantastic for senior developers who kind of just need to get their tickets done. But in those first few years of your career, if what you were saying was we should be in the office, I could not agree more when it comes to developers just starting their careers. I think it'll help you. I mean, you'll probably learn twice as fast as if you were remote. So get their tickets done. So if I'm a junior or brand new coming out of boot dev or anywhere else, and I show up in the office, but then I don't have that senior dev support in the office, because they don't have to be there because they're senior devs, I'm still in the same situation, right? Yeah, that's a good point. I mean, it doesn't help if the rest of the team isn't there. You don't get that. So I'm also not saying that all senior devs should all be remote. But when it comes to like, you know, if you're trying to engineer the best situation for yourself, the best learning situation for yourself, again, I'm really concerned with like the first, maybe one to three years of your career, if you can find a job where you can go into the office and be around other developers, ideally seniors, it's okay if they only have a couple years of experience, you could probably still learn from them as well. But just being in that collaborative environment, I think is super helpful. Like I said, I've worked remote as a senior developer, I never did as a junior developer. Remote work is great for a number of reasons. But the one thing it's not good for is bouncing ideas around a small team and kind of learning from peers. And the reason why I'm pressing on this is this takes us back to my skilled trades comments a few minutes ago. Effectively, if you can get somebody in working with not necessarily a senior, but somebody that's at least more advanced, that's the model of the apprentice. And if you can apprentice something, then at some point, you can flip out and go start your own thing. And in our world, that would be becoming a senior and then doing whatever the senior does. I think the analogy is a really strong one. Like I said, I see software development, kind of as a skilled trade, but it's a weird, unique skilled trade. And that like, if we were to take front end web development, I think that's probably the best way to go about it. I think that's probably the closest thing to a skilled trade in the sense that you generally don't need like crazy deep theoretical academic knowledge in order to be successful. On the back end, a lot of times you don't, but sometimes you do. Right. And even sometimes on the front end, you do, I just say maybe those scenarios are a bit less frequent, but it's this weird industry where a lot of the time you're doing fairly simple stuff. And you're mostly concerned with architecting applications that could be maintained into the future that can be deployed quickly, right? That suit business needs and fulfill business goals. But then occasionally you'll get this crazy product requirement coming in that isn't solved by some PIP install or an NPM install. And you actually do need to do some hard engineering work. And that's like not really a common thing in a lot of other trades, right? And when it is, you would actually pull in an engineer, right? An electrician would pull in an electrical engineer rather than necessarily trying to do it themselves. Whereas we live in this industry where it's kind of funny, we're all seen as software engineers and we're kind of doing both the kind of skilled labor as well as sometimes the harder, more theoretical, academic, mathematic engineering work. So what makes your dopamine increase today? Use the phrase earlier, dopamine inducing. What makes your dopamine increase today? Like personally for me, as I work on boot dev. Yes. Oh man, that's a really good question. I think it's the same as it always has been for me in engineering, releasing new features. I get a deep, sick satisfaction from deleting code. That's always been my favorite thing to do. In fact, nine months ago, a year ago, I deleted an entire course from the boot dev platform because I deemed it outside of the scope of what we were trying to accomplish. It was a graphics course. And I really wanted to kind of niche down the platform on backend engineering. And so I deleted this graphics course that had you using like HTML five canvas. And like it hurt because a lot of work had gone into the course, but I still just get a hit from deleting stuff because deleted stuff can't break. Victor, does that sound familiar to you? Oh yeah. There are very few things more satisfying than removing stuff, removing code. I mean, many people do not often or ever delete something completely, but in my case, I would rephrase it maybe refactoring. Removing things and replacing with something more efficient or easier to understand or whatever the reason is, that's extremely satisfying. Is that almost more satisfying than the initial launching, initial land? Because if you launch something, I'm going to go to SpaceX. I watched the SpaceX launches. Those are always great. See the lift off. But to me, I watch for the landing because that's more important to me because then I know I can move on to the next theme because I can reuse that one again. I guess that also depends on seniority. I've been in industry for too long to know that actually the launch is never successful. It's never what people need. I mean, in the past, it was different because you would work for three years or something and then you would say, hey, people, I finally finished. Now we're launching a month later. We all know that it's not what people need. We all know that it's not something that will work. But launching is not that exciting anymore. I get more excited by solving a bug. And I'm not speaking about typical bugs, like the color is wrong or things like that. But hey, actually, we have a serious issue. Those days when you say things are down, nothing is working. We have some problem in production and you solve it and nobody really congratulates you for it. But I feel great in those cases. Yeah. So I practice pretty rigorous continuous deployment and I always have. Launching, quote unquote, multiple times per day. I probably updated the courses on the app six times today. Just adding an exercise here, ripping something out there, making changes to the front end itself, multiple times a day, per day. So there's not this big hit that I get that I would get, for example, at a company that I worked in the past. We release software every six weeks. Those launches, I guess they would have been dopamine-inducing, except for there was always six weeks worth of bugs bundled up into the deployment. So it was actually more fear than anything. Six weeks is when I considered back in the day, oh, now we're going too fast. I'm talking about releasing half a year, twice a year, right? I've never worked in that environment, but I can only imagine because six weeks to me seemed so dangerous and slow. You are a child. You have much to learn of the way. Well, hopefully we never go back to that. So we'll see. I mean, I'm sure I have much to learn, but. Well, some people have never left it. So you've brought up the platform that you're on. I'm going to ask this question. What is boot dev running on? I have a feeling it's a custom role. Yeah, fully custom, which like from a business standpoint may have not been the right decision two years ago, but certainly now it is. I'm very interested in how we can teach this back end stuff in a non-video way. And that's not to say I hate videos. We have some videos on the platform that walk you through some stuff like that. I'm not a stranger to the camera, but so much of online programming learning is just watching a three hour video. And to me, that's just not engaging enough. So many people watch those courses all the way through without ever putting their hands on the keyboard without pausing to do stuff. So I'm really trying to think through how we can take something weird, right? So for example, we have a web servers course where you're building a web server. How can we make that experience hands-on where you're getting feedback every step of the way, right? You add a new HTTP handler, and now you run a test in your browser to check if your HTTP handler is behaving as expected. If it is great, you unlock an achievement, you get some experience points, like all of these things kind of trigger when that happens. And the only way that's possible is to just build the whole thing from scratch. So what is it running on? You mentioned a few other platforms earlier, just throwing out some names. If you don't mind, can you pull the cover back on it and say, we're using this for this, we're using this for that? Yeah, 100%. So our backend is a services-based Go application running on Kubernetes. So there's kind of six different services. There's kind of one main API gateway that's used, and then we have a couple of different services to run specific stuff. So for example, we have one service that runs SQL lite on the backend for our SQL course, right? We have another service that kind of acts as a mock REST API for our HTTP course. So it's kind of some weird one-off technologies. All of that's running in a Kubernetes cluster on Google Cloud Platform. I'm using autopilot, GKE. Our front end is a completely decoupled single page application. It's a view three single page application. I deploy that on Netlify. The app itself, the front end SPA runs on boot.dev. My API runs on API.boot.dev. They're just completely separate. We're using Postgres as our database. And Google PubSub is, I guess, would be kind of the last critical part of the architecture. I use PubSub to do kind of event-driven stuff with like unlocking achievements, awarding experience points, that kind of stuff. So you're running on GCP. Why did you pick them over AWS, Azure, or even some of the smaller players? So I've never done a significant amount of work on Azure. So just lack of experience with Azure is why I didn't deploy there. I've done a lot with AWS and I started on AWS. Then I ran out of free credits on AWS. This is back when it's still a side project. So I switched to GCP and had 2000 more dollars of free credits. Kubernetes is an amazing abstraction layer in that I barely care, which large cloud provider I'm using, generally speaking. Kubernetes is what my application code, I guess, I mean, even then my application code doesn't really care. It's just Docker images all the way down, but it was really easy to just kind of move it over and get more free stuff. If we would exclude from your story Google Pub Sub, you could just as well tomorrow move it to Digital Ocean, Linode, Siwo, any of those. Yeah, that's actually true. Before I was on GCP, I didn't have that Pub Sub architecture. So I would have to do something different now if I were to move again. But I do like GCP, or at least I don't really have any problems with it. I have found that the ability to separate the two is really nice. It's like a staging project and a prod project. That kind of stuff is great. Oh, man. I tend to delete things a lot. You delete code, I tend to delete stuff, clusters, this or that. Infrastructure, yeah. Yeah. And the ability to have projects in Google Cloud or whatever is the name, groups in Azure, that alone would move it over one of those two instead of AWS. Hanging resources, dangling resources in AWS is no fun. Yeah. So a couple companies ago, I was very concerned with this dangling resources problem. We ended up consolidating everything in Terraform for exactly that reason. It just took so long to figure out what infrastructure is in this AWS. And I think that's the reason why we're doing this. It's like a 10-year-old AWS account and there's just stuff all over the place. You know, even if you standardize on Terraform, you're still going to have dangling resources. A simple example is that you're going to create an EKS cluster with Terraform, and then you're going to install Ingress in that cluster. And Ingress is going to create the external load balancer. And then you're going to delete that cluster and load balancer is going to stay there. Or you're not going to be able to delete the cluster because VPC is still connected to the ELB. Yeah, I couldn't agree more. I mean, boot dev is still fairly small from an infrastructure standpoint. We've grown by way of users and revenue about 10x in the last year. But still, we're just a spec compared to some of the companies I've worked for in the past when it comes to scale. So at some point, I'll have to tackle more of the same stuff. So at some point, I'll have to tackle more hairy infrastructure problems. But for now, a really simple Kubernetes cluster that costs me what? 100 bucks a month is pretty easy to manage. It always starts out innocent like that, doesn't it? Well, the question is, is do you really even need Kubernetes now? Could you get by with GCR and the new features that they have been dropping into GCR recently? That's a really good question. I looked at it. I have not done the research. My guess is I could. I mean, it runs Docker containers. It scales up and it scales down. So almost certainly. Like we said, the only other pieces of infrastructure really are a Postgres database and access to PubSub. So I'm sure I could run it on GCR. And I am really interested in exploring even more serverless stuff. So Autopilot was really great when I moved from Amazon's version of Kubernetes to GCP Autopilot because effectively now, the idea of nodes are completely abstracted away from me. All I have to think about is the pod level, which is fantastic. I love that. But it would be even nicer to just think about it or to think, I should say, to think even less about it and to not even have to worry about all the crazy things I can do with Helm and cube CTL and kind of just allow a serverless container to spin up and spin down. Yeah. As we like to say around here, here's my image, go run it and not care about anything else. That is the way. Yeah. This is the way. That's a Mandalorian reference just in case you didn't catch that, kids. So let's circle back to your CI-CD idea that you're trying to figure out. And since you enjoy releasing, you said what, five, six, seven times today? Yeah. How are you doing that today? Are you dogfooding your own CD? You said CD, but what is CD to you? Yeah. So at a small company like this, where we don't have like crazy collaboration issues, it's literally me and one other employee, we just merge to main to deploy. And if I rip back the curtains, technically what that means is just a GitHub action that bundles up my go binary plus some dependencies into a Docker image, throws it up onto Google's image registry. Can you remember what the name of their image registry is? And then pulls it down using cube CTL Helm commands, right? Onto the cluster. So all that happens just kind of in a GitHub action for the backend. For the front end, it's even simpler. I've just connected, it's a single page application. I've just connected it to Netlify. Again, if I merge code into my front end application repository, Netlify kind of automatically deploys it. That's like a non-negotiable thing for me. There's that classic XKCD that's like, you know, if you spend a lot of time automating something, then maybe the automation wasn't worth it because now you've wasted all this upfront time automating when really the manual task was pretty quick. I've seen people make that argument for CD. I think it's just absolute nonsense. Setting up continuous deployment for me at this point takes usually less than an hour to set up well. And I just never have to worry about it again. Again, even on side projects, I basically refuse to work without continuous deployment. Continuous integration tests and everything. Like I'll forego that long before I'll forego continuous deployment. It's one of those things that can be a big investment if you're not experienced with it. But my experience or my feeling about it is that actually it's faster from the very start if you do those things, assuming that you're not in a stage, oh, I need to figure out how GitHub Actions work. Or even testing, right? To me, I'm so used to test-driven development that to me, it goes faster from the very start. But there is that problem if you're not familiar with it. It can delay whatever you're doing significantly. But if you are, it's faster from the start. Yeah. My belief is just that in 2023, it's so fundamental to especially web development, that even if you have to spend... I mean, if you're an experienced developer, it'll take less than a day to figure out how GitHub Actions work. If you're a brand new developer, it might take a little longer because you'll be running into things like, oh, I didn't understand that this is built on top of node. No, I didn't understand that this requires some basic knowledge of bash and all this kind of stuff. But learning that stuff upfront, I think, is just... It honestly is just, in my opinion, a prerequisite to becoming a backend developer. And so again, that's why it's going into this backend developer learning path that I'm putting together. And yeah, it's just in the long run, it saves you so much time. I can't imagine working by SSHing onto a box and doing a Git pull or FTPing files anymore. That was awful. I hated that. So maybe then the first contact with software for somebody who is just starting shouldn't be front-end or backend then, but maybe very basic Linux. Because that's actually the base of... You mentioned CI, right? That's really Linux. Whomever understands how to run stuff from a terminal should not have a problem with GitHub Actions. Yeah. The best GitHub Actions, in my opinion, are the ones that are the least GitHub actiony, right? They have more bash lines of code in them than native GitHub Action stuff. It's easier to inspect. It's easier to see what's going on. You can copy paste the bash from the GitHub Actions and run it locally to see if it works. Is it a better starting point? Maybe. It's actually really funny. A giant proportion of our students on boot dev have a sysadmin, ops, DevOps type background. They just move through the learning path so fast because I never have to explain Git, branching, Linux, command lines, just all this fundamental IT knowledge that as a developer, a lot of developers just pick it up on the job. Because traditional CS degree, you start by learning how to code. You start by learning all this math and these algorithms, but you're never really taught, at least when I was in school, you weren't really taught all of these tools. It's like sysadmin type tools. And so yeah, my experience has been ops engineers getting into backend development, just move so fast through the content because again, they're just kind of learning the syntax and learning how to think about code. So anything else you want to talk about for boot dev? If people wanted to sign up, obviously they can go to boot.dev and it's just like it sounds boot B O O T dot dev. What are they going to experience when they land there other than some really cool mid-journey imagery? Yeah, we're just an art platform. So the whole purpose of boot dev is to get you ready for a job in backend development. And we have some learners that don't have that exact goal. We have some learners that are just trying to maybe pick up some scripting skills, right? They're working a lot with Python or Go in their kind of DevOps jobs. That's okay too. But really at the end of the day, the product experience is tailored to taking you through this full learning path. We start with things like Python, object oriented programming. And when I talk about object oriented programming, by the way, I'm talking about the conceptual stuff like polymorphism, encapsulation. I actually kind of hate classes. I'm a big fan of Go and kind of procedural programming, but I do think it's critically important to understand these different paradigms, right? Again, it kind of goes along with one of the themes of boot dev, which is just going deeper on this stuff, spending some more time to really learn the foundational stuff so that we're not trying to get jobs kind of three months out of a boot camp. So anyways, we go through object oriented programming, data structures, algorithms. You're writing a ton of code in the browser. So the actual experience of boot dev is like reading a prompt on the left-hand side, maybe watching a quick one or two minute video explaining a concept and then writing code on the right-hand side of the screen, running the code in the browser, checking to see if you got the right answer and moving on. So kind of very hands-on every step of the way. And then you're actually leaving the platform to do projects on your local machine, every other module. So it kind of goes course, course, where we learn some new conceptual stuff, and then a project where you kind of implement that conceptual stuff in something that will hopefully go live on your GitHub profile or whatever. Now, one thing I've noticed that you put out is basically a monthly newsletter that's on the blog. And since we're recording this in May, May happens to be up and you said you now have over 40,000 registered students. It's grown faster than I could have hoped when I finally was able to go full-time. So it's kind of funny. It grew really slowly for like the first year, probably due to only having one or two courses and me not really knowing what I was doing. And now it's growing faster than we can keep up with. In fact, we're thinking about bringing on a third employee at this point. We just crossed half a million completed exercises, so coding exercises on the platform. That one was really exciting for me. It's been really fun. Hopefully we're able to keep up with putting out content at the same rate. But now with the growing amounts of content we have on the platform, I also don't want to let any of it go stale. So I also do spend much more of my time updating, maintaining, and improving the existing stuff. So that's been just a new burden. That burden alone, how are you managing that? Because both Victor and I have gone through this cycle of had courses published out on different platforms. And it's like, there's no way we can keep this stuff up to date. Since you have total control over your platform, what is your magic sauce to keep things updated? It's a good question. So first, really good CD. It's really easy to make changes. So like I said, our courses are primarily text and code-based. So as opposed to videos, which are really hard to update. Text is really easy to update. We have a built-in feedback system in the app. So someone's taking it, they're on an exercise in a specific course. If they have an issue with it, or if something's out of date or whatever, they can just click a button, type into a little chat box, hey, something's wrong here. And it automatically creates a GitHub issue for us on our GitHub organization that we can go and resolve by probably just hopping in and changing the text. We get about a hundred of those tickets every week now. And so either me or my employee, we kind of switch off every other week tackling those tickets. It usually takes less than a day, again, because they're text-based courses. The other advantage we have is that for the most part, our courses are evergreen in the sense that we're not necessarily teaching so many technologies as we are teaching concepts, right? So like just to list some of our courses, we've got learn object oriented programming, learn algorithms, data structures, learn HTTP. Those are very slow moving fields of study. So it's not like we're teaching, you know, react router version, I don't know, 5.6.1, and then next month we'll have to publish a new one. So that's also been really helpful. That said, again, now we're getting into teaching more and more with technologies. Like I'm getting down to some of this Docker and Kubernetes stuff. So how we approach that going forward, I honestly think it will just need to be increasing head count as we grow and just having more resources because it is getting more challenging. So you can find bootdev at, gee, go figure, boot.dev. All of Lane's contact information will be down in the episode description. And go check it out. Lane, thanks for being with us today. Thanks so much for having me guys. This was fun. We hope this episode was helpful to you. If you want to discuss it or ask a question, please reach out to us. Our contact information and a link to the Slack workspace are at DevOpsParadox.com slash contact. If you subscribe through Apple Podcasts, be sure to leave us a review there that helps other people discover this podcast. Go sign up right now at DevOpsParadox.com to receive an email whenever we drop the latest episode. Thank you for listening to DevOps Paradox."}, "podcast_summary": "The podcast summary discusses the self-taught route to becoming a software engineer and the value of developer boot camps. The guest on the podcast, Lane Wagner from boot.dev, shares his insights on the limitations of boot camps and their overpromise of quick results. He also highlights the need for deeper learning in backend development and the importance of focusing on logical thinking and working with data and algorithms. Lane explains that boot.dev primarily focuses on backend development to cater to the demand for backend developers and provide a comprehensive learning experience. The podcast also touches on the benefits of working in skilled trades and the potential misconceptions about the software industry being the only path to good pay and working conditions. Lane shares his experience in running boot.dev, including the platform's architecture, with a backend service-based Go application running on Kubernetes and a decoupled single-page application front-end running on Netlify. He emphasizes the importance of continuous deployment and the ability to iterate quickly in the development process. The summary concludes with an invitation to visit boot.dev for a complete learning path in backend development, where learners can engage in hands-on coding exercises and real-world projects.", "podcast_guest": {"name": "Lane Wagner", "org": "", "title": "", "summary": "Not Available"}, "podcast_highlights": "Highlight 1 of the podcast: \"The self-taught route tends to push people into front end and front end frameworks. I don't think it has to be that way. I think people who are more logically minded that prefer to work with data and algorithms and the command line can still become self-taught engineers.\"\n\nHighlight 2 of the podcast: \"Well, I feel like that's a good enough reason. I think the biggest problem that I have is the over promise of how much you'll learn. Right. So just kind of from a raw educational standpoint, you can't learn web dev. Really in three months.\"\n\nHighlight 3 of the podcast: \"I think backend developers are forgotten in a sense, which is really strange because I was just pulling data on this from the Stack Overflow dev survey in 2022 last year. And what I found actually really surprised me and it was that there's actually twice as many self-identified backend developers, at least in 2022, as there were front end developers.\""}